import telebot
import sqlite3
import requests
import logging
from telebot import types
import time

# Initialize bot and set up API
API_TOKEN = "7927646488:AAESP-k-oDJwTRlCin22IfEXPxkZzfYY4cQ"
CRYPTO_PAY_API_TOKEN = "346879:AAJaauJ6q2ZqQdOzGploB7t4PCFtdT1exOr"
bot = telebot.TeleBot(API_TOKEN)

# SQLite for storing user data
def init_db():
    conn = sqlite3.connect('users.db')
    cursor = conn.cursor()
    cursor.execute(''' 
        CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            name TEXT,
            balance REAL DEFAULT 0.0,
            total_orders REAL DEFAULT 0.0
        )
    ''')
    conn.commit()
    conn.close()

init_db()

# Function to create invoice
def create_invoice(asset, amount, description):
    url = "https://pay.crypt.bot/api/createInvoice"
    payload = {
        "asset": asset,
        "amount": str(amount),
        "description": description
    }
    headers = {
        "Crypto-Pay-API-Token": CRYPTO_PAY_API_TOKEN
    }
    response = requests.post(url, json=payload, headers=headers)
    if response.status_code == 200:
        return response.json()
    else:
        logging.error(f"Error creating invoice: {response.text}")
        return None

# Function to check invoice status
def get_invoice(invoice_id):
    url = f"https://pay.crypt.bot/api/getInvoice"
    params = {
        "invoice_id": invoice_id
    }
    headers = {
        "Crypto-Pay-API-Token": CRYPTO_PAY_API_TOKEN
    }
    response = requests.get(url, params=params, headers=headers)
    if response.status_code == 200:
        return response.json()
    else:
        logging.error(f"Error getting invoice: {response.text}")
        return None

# Start menu
@bot.message_handler(commands=['start'])
def send_welcome(message):
    bot.send_message(
        message.chat.id,
        "âœ¨Thank you for choosing our service. Here you will find promo codes for various cryptocurrencies. Don't worry about security, we sell only guaranteed promo codes.",
        reply_markup=start_menu()
    )

# Main menu
def start_menu():
    keyboard = types.ReplyKeyboardMarkup(resize_keyboard=True)
    keyboard.add(types.KeyboardButton("ğŸ“ Rules"))
    keyboard.add(types.KeyboardButton("ğŸ‘¤ Profile"))
    keyboard.add(types.KeyboardButton("ğŸ” Find promo code"))
    return keyboard

# Handler for "Rules" button
@bot.message_handler(func=lambda message: message.text == "ğŸ“ Rules")
def show_rules(message):
    bot.send_message(message.chat.id, "ğŸ“Œ All promo codes come with a 72-hour guarantee after purchase.\nâš  If the promo code becomes invalid due to your actions, a refund is not possible.")

# Handler for "Profile" button
@bot.message_handler(func=lambda message: message.text == "ğŸ‘¤ Profile")
def show_profile(message):
    user_id = message.chat.id
    conn = sqlite3.connect('users.db')
    cursor = conn.cursor()
    
    # Check if the user already exists
    cursor.execute("SELECT * FROM users WHERE user_id = ?", (user_id,))
    user = cursor.fetchone()

    if user:
        name, balance, total_orders = user[1], user[2], user[3]
    else:
        # If no user, insert them with just the first name
        first_name = message.from_user.first_name
        cursor.execute("INSERT INTO users (user_id, name) VALUES (?, ?)", (user_id, first_name))
        conn.commit()
        name = first_name  # Set the name as their first name
        balance, total_orders = 0.0, 0.0

    profile_msg = f"â¤ Name: {name}\nğŸ”‘ ID: {user_id}\nğŸ’° Your balance: {balance}\nğŸ’² Total orders: {total_orders}"
    markup = types.InlineKeyboardMarkup()
    markup.add(types.InlineKeyboardButton(text="ğŸ“œ Order History", callback_data="order_history"))
    markup.add(types.InlineKeyboardButton(text="ğŸ Referral System", callback_data="referral_system"))
    markup.add(types.InlineKeyboardButton(text="ğŸ”™ Back", callback_data="back_start"))
    bot.send_message(message.chat.id, profile_msg, reply_markup=markup)


# Order history
@bot.callback_query_handler(func=lambda call: call.data == "order_history")
def order_history(call):
    user_id = call.message.chat.id
    conn = sqlite3.connect('users.db')
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM users WHERE user_id = ?", (user_id,))
    user = cursor.fetchone()
    if user:
        total_orders = user[3]
        bot.send_message(call.message.chat.id, f"ğŸ“¦ You have {total_orders} orders.")
    else:
        bot.send_message(call.message.chat.id, "ğŸ“¦ You have no orders.")

# Referral system
@bot.callback_query_handler(func=lambda call: call.data == "referral_system")
def referral_system(call):
    user_id = call.message.chat.id
    referral_link = f"https://t.me/{bot.get_me().username}?start={user_id}"
    bot.send_message(call.message.chat.id, f"ğŸ’¡ A referral system is enabled! Invite friends and earn money.\nğŸ’° You will receive: 1% of each purchase your referral makes.\nğŸ”— Your referral link: {referral_link}")

@bot.message_handler(func=lambda message: message.text == "ğŸ” Find promo code")
def find_promo_code(message):
    # Send "Spinning the wheel..." message and remove keyboard
    markup = types.ReplyKeyboardRemove()
    sent_message = bot.send_message(message.chat.id, "ğŸ° Spinning the wheel...", reply_markup=markup)

    # Delay 3 seconds
    time.sleep(3)

    # Delete the message
    bot.delete_message(message.chat.id, sent_message.message_id)

    # Send main message
    markup = types.InlineKeyboardMarkup()
    markup.add(types.InlineKeyboardButton(text="ğŸ’° Buy promo code", callback_data="buy_promo"))
    markup.add(types.InlineKeyboardButton(text="ğŸ”™ Back", callback_data="back_start"))
    bot.send_message(message.chat.id, "ğŸ“ƒ Platform: {link} (hidden)\nğŸ“ƒ Promo code: {code} (hidden)", reply_markup=markup)

# Handler for buying promo code
@bot.callback_query_handler(func=lambda call: call.data == "buy_promo")
def buy_promo(call):
    asset = 'USDT'
    amount = 5
    send_invoice(call.message, asset, amount, 'Buying promo code')

# Function to create and send invoice
def send_invoice(message, asset, amount, period):
    invoice = create_invoice(asset, amount, f'Payment for {period}')
    if invoice and 'result' in invoice:
        invoice_data = invoice['result']
        keyboard = types.InlineKeyboardMarkup()
        keyboard.add(types.InlineKeyboardButton(text='ğŸ’° Pay', url=invoice_data['pay_url']))
        keyboard.add(types.InlineKeyboardButton(text='ğŸ”„ Check', callback_data=f'check|{invoice_data["invoice_id"]}|{amount}|{asset}|{period}'))
        keyboard.add(types.InlineKeyboardButton(text='ğŸ”™ Back', callback_data='back_start'))
        bot.send_message(message.chat.id,
                         f'Amount to pay: {amount} {asset}\n'
                         f'Once the payment is complete, click "Check" to confirm.',
                         reply_markup=keyboard)
    else:
        bot.reply_to(message, 'An error occurred while creating the invoice. Please try again later.')

# Handler for payment status check
@bot.callback_query_handler(func=lambda call: call.data.startswith('check'))
def check_payment(call):
    _, invoice_id, amount, asset, period = call.data.split('|')
    invoice_data = get_invoice(invoice_id)
    if invoice_data and invoice_data['result']['status'] == 'paid':
        bot.send_message(call.message.chat.id, f"âœ… Payment of {amount} {asset} successfully completed.\nYour promo code: {invoice_data['result']['code']}")
    else:
        bot.send_message(call.message.chat.id, "âŒ Payment not confirmed. Please try again later.")

# Handler for "Back" button
@bot.callback_query_handler(func=lambda call: call.data == "back_start")
def back_to_start(call):
    bot.send_message(
        call.message.chat.id,
        "You are now back at the main menu.",
        reply_markup=start_menu()
    )

# Start bot
bot.polling(none_stop=True)


import telebot
import sqlite3
import requests
import logging
from telebot import types
import time

# Initialize bot and set up API
API_TOKEN = "7927646488:AAESP-k-oDJwTRlCin22IfEXPxkZzfYY4cQ"
CRYPTO_PAY_API_TOKEN = "346879:AAJaauJ6q2ZqQdOzGploB7t4PCFtdT1exOr"
bot = telebot.TeleBot(API_TOKEN)

# SQLite for storing user data
def init_db():
    conn = sqlite3.connect('users.db')
    cursor = conn.cursor()
    cursor.execute(''' 
        CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            name TEXT,
            balance REAL DEFAULT 0.0,
            total_orders REAL DEFAULT 0.0
        )
    ''')
    conn.commit()
    conn.close()

init_db()

# Function to create invoice
def create_invoice(asset, amount, description):
    url = "https://pay.crypt.bot/api/createInvoice"
    payload = {
        "asset": asset,
        "amount": str(amount),
        "description": description
    }
    headers = {
        "Crypto-Pay-API-Token": CRYPTO_PAY_API_TOKEN
    }
    response = requests.post(url, json=payload, headers=headers)
    if response.status_code == 200:
        return response.json()
    else:
        logging.error(f"Error creating invoice: {response.text}")
        return None

# Function to check invoice status
def get_invoice(invoice_id):
    url = f"https://pay.crypt.bot/api/getInvoice"
    params = {
        "invoice_id": invoice_id
    }
    headers = {
        "Crypto-Pay-API-Token": CRYPTO_PAY_API_TOKEN
    }
    response = requests.get(url, params=params, headers=headers)
    if response.status_code == 200:
        return response.json()
    else:
        logging.error(f"Error getting invoice: {response.text}")
        return None

# Start menu
@bot.message_handler(commands=['start'])
def send_welcome(message):
    bot.send_message(
        message.chat.id,
        "âœ¨Thank you for choosing our service. Here you will find promo codes for various cryptocurrencies. Don't worry about security, we sell only guaranteed promo codes.",
        reply_markup=start_menu()
    )

# Main menu
def start_menu():
    keyboard = types.ReplyKeyboardMarkup(resize_keyboard=True)
    keyboard.add(types.KeyboardButton("ğŸ“ Rules"))
    keyboard.add(types.KeyboardButton("ğŸ‘¤ Profile"))
    keyboard.add(types.KeyboardButton("ğŸ” Find promo code"))
    return keyboard

# Handler for "Rules" button
@bot.message_handler(func=lambda message: message.text == "ğŸ“ Rules")
def show_rules(message):
    bot.send_message(message.chat.id, "ğŸ“Œ All promo codes come with a 72-hour guarantee after purchase.\nâš  If the promo code becomes invalid due to your actions, a refund is not possible.")

# Handler for "Profile" button
@bot.message_handler(func=lambda message: message.text == "ğŸ‘¤ Profile")
def show_profile(message):
    user_id = message.chat.id
    conn = sqlite3.connect('users.db')
    cursor = conn.cursor()
    
    # Check if the user already exists
    cursor.execute("SELECT * FROM users WHERE user_id = ?", (user_id,))
    user = cursor.fetchone()

    if user:
        name, balance, total_orders = user[1], user[2], user[3]
    else:
        # If no user, insert them with just the first name
        first_name = message.from_user.first_name
        cursor.execute("INSERT INTO users (user_id, name) VALUES (?, ?)", (user_id, first_name))
        conn.commit()
        name = first_name  # Set the name as their first name
        balance, total_orders = 0.0, 0.0

    profile_msg = f"â¤ Name: {name}\nğŸ”‘ ID: {user_id}\nğŸ’° Your balance: {balance}\nğŸ’² Total orders: {total_orders}"
    markup = types.InlineKeyboardMarkup()
    markup.add(types.InlineKeyboardButton(text="ğŸ“œ Order History", callback_data="order_history"))
    markup.add(types.InlineKeyboardButton(text="ğŸ Referral System", callback_data="referral_system"))
    markup.add(types.InlineKeyboardButton(text="ğŸ”™ Back", callback_data="back_start"))
    bot.send_message(message.chat.id, profile_msg, reply_markup=markup)


# Order history
@bot.callback_query_handler(func=lambda call: call.data == "order_history")
def order_history(call):
    user_id = call.message.chat.id
    conn = sqlite3.connect('users.db')
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM users WHERE user_id = ?", (user_id,))
    user = cursor.fetchone()
    if user:
        total_orders = user[3]
        bot.send_message(call.message.chat.id, f"ğŸ“¦ You have {total_orders} orders.")
    else:
        bot.send_message(call.message.chat.id, "ğŸ“¦ You have no orders.")

# Referral system
@bot.callback_query_handler(func=lambda call: call.data == "referral_system")
def referral_system(call):
    user_id = call.message.chat.id
    referral_link = f"https://t.me/{bot.get_me().username}?start={user_id}"
    bot.send_message(call.message.chat.id, f"ğŸ’¡ Earn rewards with our referral system! Invite your friends and get rewarded for every purchase they make.\nğŸ’° Your earnings: 1 point for each successful purchase made through your referral.\nğŸ”— Your unique referral link: {referral_link}")


@bot.message_handler(func=lambda message: message.text == "ğŸ” Find promo code")
def find_promo_code(message):
    # Send "Spinning the wheel..." message and remove keyboard
    markup = types.ReplyKeyboardRemove()
    sent_message = bot.send_message(message.chat.id, "ğŸ° Spinning the wheel...", reply_markup=markup)

    # Delay 3 seconds
    time.sleep(3)

    # Delete the message
    bot.delete_message(message.chat.id, sent_message.message_id)

    # Send main message
    markup = types.InlineKeyboardMarkup()
    markup.add(types.InlineKeyboardButton(text="ğŸ’° Buy promo code", callback_data="buy_promo"))
    markup.add(types.InlineKeyboardButton(text="ğŸ”™ Back", callback_data="back_start"))
    bot.send_message(message.chat.id, "ğŸ“ƒ Platform: {link} (hidden)\nğŸ“ƒ Promo code: {code} (hidden)", reply_markup=markup)

# Handler for buying promo code
@bot.callback_query_handler(func=lambda call: call.data == "buy_promo")
def buy_promo(call):
    asset = 'USDT'
    amount = 5
    send_invoice(call.message, asset, amount, 'Buying promo code')

# Function to create and send invoice
def send_invoice(message, asset, amount, period):
    invoice = create_invoice(asset, amount, f'Payment for {period}')
    if invoice and 'result' in invoice:
        invoice_data = invoice['result']
        keyboard = types.InlineKeyboardMarkup()
        keyboard.add(types.InlineKeyboardButton(text='ğŸ’° Pay', url=invoice_data['pay_url']))
        keyboard.add(types.InlineKeyboardButton(text='ğŸ”„ Check', callback_data=f'check|{invoice_data["invoice_id"]}|{amount}|{asset}|{period}'))
        keyboard.add(types.InlineKeyboardButton(text='ğŸ”™ Back', callback_data='back_start'))
        bot.send_message(message.chat.id,
                         f'Amount to pay: {amount} {asset}\n'
                         f'Once the payment is complete, click "Check" to confirm.',
                         reply_markup=keyboard)
    else:
        bot.reply_to(message, 'An error occurred while creating the invoice. Please try again later.')

# Handler for payment status check
@bot.callback_query_handler(func=lambda call: call.data.startswith('check'))
def check_payment(call):
    _, invoice_id, amount, asset, period = call.data.split('|')
    invoice_data = get_invoice(invoice_id)
    if invoice_data and invoice_data['result']['status'] == 'paid':
        bot.send_message(call.message.chat.id, f"âœ… Payment of {amount} {asset} successfully completed.\nYour promo code: {invoice_data['result']['code']}")
    else:
        bot.send_message(call.message.chat.id, "âŒ Payment not confirmed. Please try again later.")

# Handler for "Back" button
@bot.callback_query_handler(func=lambda call: call.data == "back_start")
def back_to_start(call):
    bot.send_message(
        call.message.chat.id,
        "You are now back at the main menu.",
        reply_markup=start_menu()
    )

# Start bot
bot.polling(none_stop=True)
